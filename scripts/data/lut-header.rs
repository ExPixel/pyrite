// GENERATED BY scripts/generate-lookup-tables.py
use super::cpu::InstrFn;
use super::{alu, arm, thumb};
use crate::alu::{
    ConstReg, RegAt, RegAtValue, RegValue, ThumbRegisterList, ThumbRegisterListWithLr,
    ThumbRegisterListWithPc, WordAlignedPc,
};
use crate::transfer::{
    HalfwordAndSignedImmOffset, HalfwordAndSignedRegOffset, Ldm, Ldr, Ldrb, Ldrh, Ldrsb, Ldrsh,
    PostDecrement, PostIncrement, PreDecrement, PreIncrement, SDTImmOffset, Stm, Str, Strb, Strh,
    ThumbImm5, ThumbImm5ExtendedTo6, ThumbImm5ExtendedTo7, ThumbImm8ExtendedTo10,
    ThumbRegisterOffset,
};
use util::bits::BitOps as _;

pub fn decode_arm_opcode(opcode: u32) -> InstrFn {
    let opcode_row = opcode.get_bit_range(20..=27);
    let opcode_col = opcode.get_bit_range(4..=7);
    let opcode_idx = (opcode_row * 16) + opcode_col;
    ARM_OPCODE_TABLE[opcode_idx as usize]
}

pub fn decode_thumb_opcode(opcode: u32) -> InstrFn {
    let opcode_row = opcode.get_bit_range(12..=15);
    let opcode_col = opcode.get_bit_range(8..=11);
    let opcode_idx = (opcode_row * 16) + opcode_col;
    THUMB_OPCODE_TABLE[opcode_idx as usize]
}

const S_FLAG_SET: bool = true;
const S_FLAG_CLR: bool = false;
const A_FLAG_SET: bool = true;
const A_FLAG_CLR: bool = false;
const SIGNED: bool = true;
const UNSIGNED: bool = false;
const WRITEBACK: bool = true;
const NO_WRITEBACK: bool = false;
const FORCE_USER_MODE: bool = false;
const SWP_WORD: bool = false;
const SWP_BYTE: bool = true;

const COND_EQ: u32 = 0x0;
const COND_NE: u32 = 0x1;
const COND_CS: u32 = 0x2;
const COND_CC: u32 = 0x3;
const COND_MI: u32 = 0x4;
const COND_PL: u32 = 0x5;
const COND_VS: u32 = 0x6;
const COND_VC: u32 = 0x7;
const COND_HI: u32 = 0x8;
const COND_LS: u32 = 0x9;
const COND_GE: u32 = 0xA;
const COND_LT: u32 = 0xB;
const COND_GT: u32 = 0xC;
const COND_LE: u32 = 0xD;
